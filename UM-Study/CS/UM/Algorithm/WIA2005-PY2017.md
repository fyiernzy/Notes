# Part A
1. $O(n)$
2. XXX


## Question 3
### 3a)
- Quicksort's worst-case time complexity is $O(n^2)$, occurring when the pivot selection results in highly unbalanced partitions, such as when the input array is already sorted. 
  
- For instance, in `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`, selecting the last element as the pivot results in partitions of size `n-1` and `1` at each step. 
  
- The total number of comparisons can be represented by the sum: $n + (n - 1) + (n - 2) + \ldots + 1$
  
  Summing these terms gives:   $\frac{n(n + 1)}{2}$ 
  
  Resulting in a time complexity of $O(n^2)$.

### 3b)

In the best-case scenario, Quicksort partitions the array into two equal halves at each step. The recurrence relation for this case is: $T(n) = 2T\left(\frac{n}{2}\right) + n$

Using the recurrence tree method, each level of the tree has a total cost of $n$, and there are $\log_2 n$ levels. Thus, the total time complexity is: $T(n) = n \log_2 n$. Therefore, the time complexity is $O(n \log n)$.

### 3c)
1. **Calculate the midpoint**: Determine the midpoint of the array or subarray.
2. **Check the midpoint value**: Compare the value at the midpoint with its expected value.
   - If `A[m] != m + 1`, it means the missing number is either at the midpoint or in the left subarray:
     - If the midpoint is the first element or the element before the midpoint is in the correct position, then the missing number is `m + 1`.
     - Otherwise, search in the left subarray.
   - If `A[m] == m + 1`, continue the search in the right subarray.

**Pseudocode**:
```pseufo
FINDMISSINGNUMBER(A, i, j):
    m = i + (j - i) // 2
    if A[m] != m + 1:
        if m == 0 or A[m-1] == m:
            return m + 1
        return FINDMISSINGNUMBER(A, i, m - 1)
    return FINDMISSINGNUMBER(A, m + 1, j)
```

This algorithm efficiently narrows down the search space to find the missing number in logarithmic time, $O(\log n)$.

**Additional Notes:**

- The numbers are given serially, starting from `001, 002, ...`.
- There is only one missing number, and the last running number is `998`.

If there were more missing numbers or other complexities, a different approach like linear searching would be more suitable. This would involve initializing an array of size `999`, iterating through each element to mark the presence of numbers, and then finding the index with the `false` value.
